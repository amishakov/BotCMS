# BotCMS
## Описание
Система управления для создания чат-ботов.  
Позволяет поддерживать неограниченное количество ботов в рамках одного приложения
на любых площадках. "Из коробки" поддерживаются Telegram и ВКонтакте, любые другие
возможно подключить путем написания "драйверов", выполняющих роль транспорта.

## Возможности
* Настройка ботов через простые YAML или JSON файлы (схемы);
* Использование пользовательский методов, если недостаточно встроенных проверок/действий;
* Поддержка мультиязычности
* Поддержка клавиатур
* Сборка полной схемы из неограниченного количества файлов с возможностью переопределения в порядке загрузки файлов

# Установка
$ npm install botcms --save

# Быстрый старт
Ниже пример простейшего бота, который в Telegram здоровается при получении сообщения "/start" и отправляет предложение помощи в ответ на любое другое сообщение.

**index.js**
```
const BotCMS = require('botcms');
const MVTools = require('mvtools');

let config = {
    networks: [
        {
            name: 'tg',
            token: '<TELEGRAM BOT TOKEN>'
        }
    ],
    defaults: {
        action: 'help'
    }
};
let schema = {
    scripts: {
        c: {
            help: {
                message: 'Я - великий бот-помощник! Я выполню все твои задачи! Но пока умею отвечать только на команду /start :)',
                command: true
            },
            all: {
                trigger: '/start',
                message: 'Привет!',
                command: true
            }
        }
    }
};

let bot = new BotCMS(config);
bot.loadSchema(schema)
    .then(() => bot.init())
    .then(async () => await bot.launch());
```


# Схема
Из схемы бот узнает, как обрабатывать сообщения, какие задания выполнять по расписанию,
какими фразами отвечать, и многое другое.  
В примерах ниже используется формат _YAML_. Вместо _YAML_ может использоваться _JSON_ или объект _JavaScript_.

## Общие положения
### Имена методов
Все методы указываются относительно глобального объекта process. Таким образом, для успешного выполнения метода 
**controllerName.methodName** должен существовать метод **process.controllerName.methodName**.

### Файлы схемы
При загрузке схема обходится рекурсивно. При обнаружении в любом месте схемы инструкции **"$FILE path/to/file"**
подгружается файл по указанному пути и сохраняется в соответствующем месте схемы.  

## Разделы схемы
* scripts - дерево "вопросов" и "ответов"
* lexicons - записи словарей
* cron - задания для выполнения по расписанию
* keyboards - готовые "клавиатуры"
* config - конфигурация

### scripts

Скрипты в схеме образуют дерево неограниченной вложенности. 

Дочерние элементы узла находятся в элементе **.c**. Пример:
```
c:
  start:
    trigger: /start
    message: Start
  parent:
    trigger: parent
    c:
      child1:
        message: Child1
      child2:
        message: Child2
``` 

#### Элементы узлов
Ни один из элементов не является обязательным.

##### command
Определяет, является ли узел командой. Отличие команд от обычных узлов в том, 
что они доступны для вызова в любой момент, независимо от текущего метсонахождения пользователя.
 
Возможное значение: **true** 

##### trigger
Условие, по которому узел считается подходящим под введенное пользователем сообщение.
Если trigger является строкой, он преобразуется к объекту:
```
trigger: 
  value: User message
```
Элементы объекта:
* type - тип проверки. Если отсутствует, считается текстом. Возможные значения:
  * regexp - регурярное выражение
  * text, method - название метода, запись словаря, текст. Независимо от значения type,
  проверка проходит именно в таком порядке. 
  * bridge - название социальной сети (транспорта), для которого актуален данный узел
* value - значение. Если указан массив значений, проверка производится до первого совпадения.

Важно: **trigger** может быть массивом объектов указанной структуры. В таком случае 
для успешного прохождения проверки все элементы массива должны дать положительный результат.

Пример расширенного **trigger**:

```
trigger:
  - type: method
    value: controllerName.methodName
  - - /start
    - Начать
    - path.of.lexicon.entry
```

##### message
Отправляемое пользователю сообщение.
Может быть:
* названием метода
* записью словаря
* текстом

##### action
Может быть как строкой, так и объектом. Если строка, преобразуется в объект:
```
action:
  type: method
  name: methodName
``` 
Обрабатываемые ключи объекта:
* **type** - тип действия. Поддерживаемые: 
  * **method** - выполнение метода
  * **send** - отправка сообщения 
* **name** - имя метода
* **params** - Набор параметров

###### Параметры для method
Объект (строка, массив) параметров будет передан в вызываемый метод в неизменном виде

###### Параметры для send
* **message** - отправляемое сообщение
* **from_scope** - ветка сохраненных ответов пользователя
* **target** - объект вида:
  ```
  bridgeName:
    - peerId1
    - peerId2
  ```

#### goto
Адрес узла для принудительного перехода.
Поддерживает следующие подстановки:
* ((self)) - текущий узел
* ((parent)) - родитель текущего узла
* ((grandpa)) - "дедушка" текущего узла
* ((children)) - элемент ".c" текущего узла

#### validate
Правила проверки ответа пользователя и последующих действий.

### lexicons


### keyboards


### cron
Список заданий. Расписание указывается в стандартном для cron формате, но с учетом секунд.
То есть, на 1 параметр больше.

Пример отправки сообщения в чат каждый час: 
```
cron:
  task1:
    trigger: 0 0 * * * 
    action: methodName      
```
Инструкции для работы находятся в ключе **action**. Подробнее - в разделе **"scripts" - "action"**.

### config
Все указанное в данном разделе будет слито с конфигом бота, задаваемым при его создании. 



